version = "3.2"


# PRIVATE

[resources]
processes = 0

[resources.cases]
input = "data/input"
output = "data/output"

[resources.conceptnet]
url = "neo4j://localhost:7687"
username = "neo4j"
password = ""

[resources.spacy]
host = "0.0.0.0"
port = 8765
workers = 1


# PUBLIC

[adaptation]
export_graph = false
export_single_stats = true
export_grid_stats = true
knowledge_graph = "wordnet"
bfs_node_limit = 4


[tuning]
# How many of the given benchmark rules should be used as an input to the adaptation process.
rules_adaptation_limit = [1]

# [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
synset_min_similarity = [0.0, 0.33, 0.67]

# Threshold for extracting/adapting concepts
extraction_min_score = [0.2]
adaptation_min_score = [0.0, 0.25, 0.5]

# Of which metrics should the score consist
# score_keyword_weight = [0.0, 0.33, 0.67, 1.0] # removed due to grid search
score_semantic_similarity = [0.33, 0.67, 1.0]
score_path_similarity = [0.33, 0.67, 1.0]
score_wup_similarity = [0.0, 0.33, 0.67]

# From what concepts should the metrics be derived
weight_original_concept = [0.5, 0.75, 1.0]
weight_rule_source = [0.0, 0.25, 0.5]
weight_rule_target = [0.0, 0.25, 0.5]

# How to perform the adaptation: direct, bfs
adaptation_method = ["bfs"]

# between: Try to transfer the concept path from (adaptation origin, adaptation destination) to (current concept, adapted concept).
# within: Try to transfer the concept path from (adaptation origin, current concept) to (adaptation destination, adapted concept).
bfs_method = ["between"]

# difference: The vector direction between the concepts should match, i.e. min cosine(abs(vec1 - vec2), abs(vec3 - vec4)).
# similarity: The absolute similarity values of the concepts should match, i.e. min abs(cosine(vec1, vec2) - cosine(vec3, vec4)).
bfs_selector = ["similarity"]


[nlp]
max_distance = 50
lang = "en"
embeddings = "spacy" # transformers, spacy


[wordnet]
hypernym_filter = [
    "entity.n",
    "abstraction.n",
    "artifact.n",
    "causal_agent.n",
    "living_thing.n",
    "object.n",
    "physical_entity.n",
    "psychological_feature.n",
    "whole.n",
]


[conceptnet]
[conceptnet.node]
root_form = true

[conceptnet.relation]
directed = true
generalization_types = [
    "DerivedFrom",
    "IsA",
    "PartOf",
    # "HasA",
]
all_types = [
    "Antonym",
    "AtLocation",
    "CapableOf",
    "Causes",
    "CausesDesire",
    "CreatedBy",
    "DefinedAs",
    "DerivedFrom",
    "Desires",
    "DistinctFrom",
    "Entails",
    "EtymologicallyDerivedFrom",
    "EtymologicallyRelatedTo",
    "ExternalURL",
    "FormOf",
    "HasA",
    "HasContext",
    "HasFirstSubevent",
    "HasLastSubevent",
    "HasPrerequisite",
    "HasProperty",
    "HasSubevent",
    "IsA",
    "IsInstanceOf",
    "LocatedNear",
    "MadeOf",
    "MannerOf",
    "MotivatedByGoal",
    "NotCapableOf",
    "NotDesires",
    "NotHasProperty",
    "ObstructedBy",
    "PartOf",
    "ReceivesAction",
    "RelatedTo",
    "SimilarTo",
    "SymbolOf",
    "Synonym",
    "UsedFor",
]

[conceptnet.path]
[conceptnet.path.max_length]
shortest_path = 10
generalization = 3
